# BST-and-MaxHeap

## 簡介：
#### 主程式：
讀入command，判斷是否為介於0到3之間的整數。若非，則輸出錯誤訊息，並請使用者重新輸入。當判斷到command為0時，直接跳出迴圈；若command為1，則呼叫Mission1()；若command為2或3，在使用者已事先輸入過1的情況下，則分別呼叫Mission2()、Mission3()。

#### 任務一：
Mission1()裡，先呼叫函式DataGet()，取得input.txt檔案裏面的資料，將資料存進structure裡，用pointer鏈接，拿head指向開頭的地方，然後依造題目要求印出讀進來的資料。

讓walk指向head指向的位置。接著，在walk不等於NULL的情況下，呼叫Build_HP_tree()，當前這筆資料和當前二元樹裡存有的資料進行比較，若比二元樹節點還要大的話，將高度加一，然後往右子樹移一格，然後再呼叫一次函數本身(遞迴)；反之，就往左子樹移一格，然後再呼叫一次函數本身。若遇到該節點為NULL的情況時，就將該筆資料插入該節點，然後比較最高樹高和當前計算出來的高度比較，若現在計算的高度比最高樹高還要高的話，就更新最高樹高，最後return，然後印出樹高。分別尋找最左邊和最右邊的節點，再分別印出。

#### 任務二：
建立最大堆積，再呼叫一次Dataget()，將資料存進一個vector裡，從最後一筆資料開始往前比較，直到vector的第一筆資料。把vector裡面的資料想成一顆二元數，若此時的資料沒有子節點時，就直接return；若有子節點，且此資料(父節點)HP比子節點的HP還要大，找出最大的子節點，和父節點交換，再呼叫一次遞迴，檢查更下一層的子節點有沒有比原本的父節點還要大。

完成最大堆積排序之後，印出新排序的資料，然後計算樹高，再分別印出樹高、最左邊的節點，和最右邊的節點。

#### 挑戰三：
要刪除樹根節點，為了保持完全二元樹的完整性，先將樹根(第一筆資料)，和最後一筆資料交換，再刪除最後一筆資料，然後再從新建一次最大堆積的二元數(方法如同任務二)。


